/*************************       Compilers Laboratory Assignment 6            ****************************/
/************************      Written by:Ankit Kumar Gupta (12CS10006)        ***************************/
/************************          Target Code Generation                ********************************/ 
// header files inclusion
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<fstream>
#include"ass6_12CS10006_translator.h"
#include <ctype.h>

// declaration of variables used 
extern list_<symtable*> *stbl;
extern FILE* yyin;
extern FILE* yyout;
extern int yyparse();
extern symtable ST_gl;
extern symtable* ST_funt;
extern qArray qarr;
extern list_<char*>* string_table; 
extern int string_counter;
using namespace std;
extern ofstream out;
ofstream sout;
extern int target[NSYMS];
int counter=1;
list_<list_<int>* > *ActRec=NULL;
extern pair<char*,int>  fn_st[30]; 
extern int pair_indx;

// main function
int main(int argc,char *argv[])
{

 char* input_file_name;
 char token_output_file_name[30];
 char quad_output_file_name[30];
 char asm_output_file_name[30];
	if(argc>1)
	{
		input_file_name=argv[1];
	}
	else 
	{	cout<<"please provide input file name"<<endl; exit(0);}
 
/**************************        Testing  input file            ************************************/
   // ST_gl.head=NULL; ST_gl.last=NULL; // initillize data before testing 
    //qArray::quadPtr=0;
    // file names
    //sprintf(input_file_name,"ass6_12CS10006_test%d.c",i);
    sprintf(token_output_file_name,"ass6_12CS10006_tokens%c.c",input_file_name[19]);
    sprintf(quad_output_file_name,"ass6_12CS10006_quads%c.out",input_file_name[19]);
    sprintf(asm_output_file_name,"ass6_12CS10006_test.s",input_file_name[19]);

   	stbl=makelist<symtable*>(&ST_gl,"Global");
  	yyin=fopen(input_file_name,"r");
  	if(!yyin) {	cout<<"test file not found"<<endl; exit(0);}
   	yyout=fopen(token_output_file_name,"w");       // tokens are generated in this file
  	int rtn;
  	rtn=yyparse();
  	if(rtn==0) cout<<"Parsed Successfully..\n";
  	fclose(yyout);   // tokens generatation finish close file

  	out.open(quad_output_file_name); // symbol table and quads are generated in this file
  	out<<"---------------------------------------------------Start--------------------------------------------------"<<endl;
  	out<<endl;
  	out<<"\t\t\t\tIntermediate code file generated by compiler\t"<<endl;
  	out<<"\t\t\t\t\t\tSymbol Tables \n";
  	while(stbl)
	{  // for all symbol tables
  		stbl->data->update_offset();	 // update offsets
  		stbl->data->print(stbl->name);  // print symbol tables
  		if(strcmp("Global",stbl->name))  // use symbol tables to generates activation record of functions
 	 	{
   			ActRec=merge(ActRec,makelist(gen_ActRec(stbl->data),stbl->name)); // generate AR and merge with the list of AR
   		}
  		stbl=stbl->next;
   	}
    // print quad array
    out<<"-----------------------------------------------------------------------------------------------------------";
   	out<<endl<<endl;
   	out<<"-----------------------------------------------------------------------------------------------------------\n";
   	out<<"\t\t\t\t\tQuad Array\n";
   	out<<"-----------------------------------------------------------------------------------------------------------"<<endl<<endl; // Quad Array Printing
  	qarr.print(); 
  	out<<"----------------------------------------------------------Finish---------------------------------------------"<<endl;
  	out<<endl;
  	out.close();       // Quad Array Printing finish close quad file

  
   	sout.open(asm_output_file_name); // Target Code gets generated in this file
   	sout<<"\t\t.file \""<<input_file_name<<"\""<<endl; 
   	gen_GLMem(&ST_gl); // generate data section which includes variables binding to  memory and some read only data of strings
   	gen_funt();        // generate code of function defintions
   	sout.close(); // close Target Code file
   	/**************************        Testing of input file finish            ************************************/

 return 0;
}



/**************************this function to get AR****************************************/
list_<int> *lookup_ActRec(char *name)
{  

  list_<list_<int>* > *p=ActRec;
   while(p){
   
     if(!strcmp(p->name,name)) 
       return p->data;
      p=p->next;
     }
 return NULL;
}



/**************************this function to get offset from AR****************************************/
int lookup_ActRecFunt(char *name,list_<int>* l)
{ 
  list_<int>*p=l;
  
   while(p)
   {
   
   if(!strcmp(p->name,name)) 
     return p->data;
    p=p->next;
   }
return 0;
}

/***************** this function is used to get Sting Lable from Table of String Constants ********************/
char *lookup_String_Table(char *name)
{
 list_<char*> *p=string_table;
  	while(p){
			if(!strcmp(name,p->data)) return p->name;
			p=p->next;
  	}

return NULL;
}

/************** this function generates Activation Record *********************************************/
list_<int> *gen_ActRec(symtable* symt)
{

list_<int> *p=NULL;

SYMT_ROW *q=symt->head;
int rel_off=8;
while(q)
{
if(strcmp("retval",q->name))
{
p=merge(p,makelist<int>(rel_off,q->name));
if(rel_off>0) rel_off+=q->size;
else rel_off-=q->size;
}

else rel_off=-4;

q=q->next;
}
return p;
}
void gen_string()
{
	list_<char*> *p=string_table;
  	while(p){
			sout<<"\t\t.section .rodata"<<endl;
            sout<<p->name<<":"<<endl;
			sout<<"\t\t.string\t"<<p->data<<endl;
			p=p->next;
  	}
}


/******** this functions binds variables to the memory *************************************/
void gen_mem(char *name,Type_Data* t,int size,char* init)
{
	
sout<<".globl "<<name<<endl;	


if(t->type_name==Int) {
	sout<<"\t\t.data"<<endl;	
sout<<"\t\t.type "<<name<<", @object"<<endl;	
sout<<"\t\t.size "<<name<<", "<<size<<endl;
sout<<name<<":";
     if(init)
           sout<<"\t\t.long "<<init<<endl;
        else
           sout<<"\t\t.zero "<<size<<endl;		
  }
 if(t->type_name==Char){
 	sout<<"\t\t.data"<<endl;	
sout<<"\t\t.type "<<name<<", @object"<<endl;	
sout<<"\t\t.size "<<name<<", "<<size<<endl;
sout<<name<<":";
        if(init)
           sout<<"\t\t.byte "<<(int)init[0]<<endl;
        else
           sout<<"\t\t.zero "<<size<<endl;			
}
 if(t->type_name==Array){
 	sout<<"\t\t.data"<<endl;	
sout<<"\t\t.type "<<name<<", @object"<<endl;	
sout<<"\t\t.size "<<name<<", "<<size<<endl;
sout<<name<<":";
        sout<<"\t\t.zero "<<size<<endl;	

   }
if(t->type_name==Pointer) {

	if(init){
		if(t->right->type_name==Char){

			sout<<"\t\t.section .rodata"<<endl;
            sout<<".LC"<<string_counter<<":"<<endl;
			sout<<"\t\t.string\t"<<init<<endl;
       				}
       			}
	 	sout<<"\t\t.data"<<endl;	
		sout<<"\t\t.type "<<name<<", @object"<<endl;	
		sout<<"\t\t.size "<<name<<", "<<size<<endl;
		sout<<name<<":";
		if(init && t->right->type_name==Char) 
				sout<<"\t\t.long "<<".LC"<<(string_counter++)<<endl;
		else
				sout<<"\t\t.zero "<<size<<endl;
	
	}
    sout<<endl;
    
return;             
}

/******** this functions binds variables to the memory calls gen_mem*************************************/
void gen_GLMem(symtable* symt){

SYMT_ROW *q=symt->head;
while(q){
if(q->type->type_name!=Function){
	gen_mem(q->name,q->type,q->size,q->initial_value);
	}
	q=q->next;
	}
	gen_string();   
	sout<<endl;
}


/******************************this to calculate offset bywhich stack should be decremented ***************/
int cal_stack_len( list_<int> * AR)
{
list_<int> *p=AR;
if(p){
if(!p->next) return -(p->data);

while(p->next) p=p->next;
return -(p->data);
}
}


 
/****** generate code for a particular function ***************************/
void gen_funt()
{
 int j=0;
 int i=1;
 char *name=fn_st[0].first; 
 int curr=fn_st[0].second;
 int next;
 if(1 < pair_indx)
   next=fn_st[1].second;
 else  next=qArray::quadPtr;




 list_<int> *AR=lookup_ActRec(name);
 
   
 while(j<qArray::quadPtr)
{ 

	int no_param=0;
        int max=0;
	int indx=curr;
  	while(indx<next){

              while(indx<next && target[indx]==-1)  { no_param++; indx++;}
		
		   if(no_param>max) max=no_param;
		
                    no_param=0; indx++;	
		}

   
   if(curr<next)  {
                sout<<"\t.text"<<endl;sout<<"\t.globl\t"<<name<<endl<<"\t.type\t"<<name<<",@function"<<endl;
		sout<<name<<":"<<endl;
			gen_prologue();
   int stack_len=cal_stack_len(AR)+max*4; 
   sout<<"\tsubl\t$"<<stack_len<<",\%esp"<<endl;
   for(; (curr<next) && (j<qArray::quadPtr);j++,curr++)
     conv(j,AR);
    
     sout<<"\taddl\t$"<<stack_len<<",\%esp"<<endl;
     gen_epilogue();
	
	}   

  name=fn_st[i].first;
  curr=fn_st[i].second;
 if(i+1 < pair_indx)
  next=fn_st[i+1].second;
 else  { next=qArray::quadPtr;}
   if(name) AR=lookup_ActRec(name);
  
 i++;
} 

}

void gen_prologue()        { sout<<"\tpushl\t\%ebp \n\tmovl\t\%esp,\%ebp\n";}

void gen_epilogue()	   { sout<<"\tpopl\t\%ebp \n\tret\n"<<endl; }


// checks whethet number is numeric or not
int isNumeric (const char * s)
{
    if (s == NULL || *s == '\0' || isspace(*s))
      return 0;
    char * p;
    strtod (s, &p);
    return *p == '\0';
}

// conv a quad into assembly code
void  conv(int j,list_<int> *AR)
{ 
  
   char *arg1=qarr.qarr_[j]->arg1;
   char *arg2=qarr.qarr_[j]->arg2;
   char *result=qarr.qarr_[j]->result;	
   opcodeType op=qarr.qarr_[j]->op;

   if(target[j+PC]==1) sout<<".L"<<j+PC<<":"<<endl;	
  if(arg2!=0) //Binary Operator
	{ 
               
   
	           int arg1_off= lookup_ActRecFunt(arg1,AR);		
               int arg2_off= lookup_ActRecFunt(arg2,AR);
               int rslt_off= lookup_ActRecFunt(result,AR);
   
              
               char *ebp="\%ebp";
               if(arg1_off) { arg1=new char[30];  sprintf(arg1,"%d(%s)",arg1_off,ebp);}
	       if(arg2_off) { arg2=new char[30];  sprintf(arg2,"%d(%s)",arg2_off,ebp);}
	       if(rslt_off) { result=new char[30];  sprintf(result,"%d(%s)",rslt_off,ebp);}
		if(isNumeric(arg1)) {char *buffer= new char[20]; sprintf(buffer,"$%s",arg1); arg1=buffer;}	 	
			else if(arg1[0]=='\'')	{int c=arg1[1]; sprintf(arg1,"$%d",c);}
		if(isNumeric(arg2)) {char *buffer= new char[20]; sprintf(buffer,"$%s",arg2); arg2=buffer;}	 	
			else if(arg2[0]=='\'')	{int c=arg2[1]; sprintf(arg2,"$%d",c);}
		
         

		switch(op)
		{
			case PLUS : 	
				
        			sout<<"\tmovl\t"<<arg1<<",\%edx"<<endl;
	     			sout<<"\tmovl\t"<<arg2<<",\%eax"<<endl;
				sout<<"\taddl\t"<<"\%edx,"<<"\%eax"<<endl;
				sout<<"\tmovl\t"<<"\%eax,"<<result<<endl; 
			break;
			case MINUS:  
				sout<<"\tmovl\t"<<arg1<<",\%edx"<<endl;
	     			sout<<"\tmovl\t"<<arg2<<",\%eax"<<endl;
				sout<<"\tsubl\t"<<"\%eax,"<<"\%edx"<<endl;
				sout<<"\tmovl\t"<<"\%edx,"<<result<<endl; 

			break;
			case MULT:
				sout<<"\tmovl\t"<<arg1<<",\%edx"<<endl;
	     			sout<<"\tmovl\t"<<arg2<<",\%eax"<<endl;
				sout<<"\timull\t"<<"\%edx,"<<"\%eax"<<endl;
				sout<<"\tmovl\t"<<"\%eax,"<<result<<endl;
			break;
			case DIV:
				sout<<"\tmovl\t"<<arg1<<",\%eax"<<endl;
	     			sout<<"\tmovl\t"<<arg2<<",\%edx"<<endl; 
				sout<<"\tmovl\t\%edx,-4(\%ebp)"<<endl;
				sout<<"\tmovl\t\%eax,\%edx"<<endl;
  				sout<<"\tsarl\t$31,\%edx"<<endl;
				sout<<"\tidivl\t-4(\%ebp)"<<endl;
				sout<<"\tmovl\t"<<"\%eax,"<<result<<endl;

			break;
			case MOD: 
				sout<<"\tmovl\t"<<arg1<<",\%eax"<<endl;
	     			sout<<"\tmovl\t"<<arg2<<",\%ecx"<<endl;
                                sout<<"\tmovl\t\%eax,\%edx"<<endl;
				sout<<"\tsarl\t$31,\%edx"<<endl;
				sout<<"\tidivl\t\%ecx"<<endl;
				sout<<"\tmovl\t"<<"\%edx,"<<result<<endl;
			break;
			case  UAND: 
					sout<<"\tmovl\t"<<arg1<<",\%edx"<<endl;
					sout<<"\tmovl\t"<<arg2<<",\%eax"<<endl;
					sout<<"\tandl\t\%edx,\%eax"<<endl;
					sout<<"\tmovl\t"<<"\%eax,"<<result<<endl;
			break;
			case XOR: 
					sout<<"\tmovl\t"<<arg1<<",\%edx"<<endl;
					sout<<"\tmovl\t"<<arg2<<",\%eax"<<endl;
					sout<<"\txorl\t\%edx,\%eax"<<endl;
					sout<<"\tmovl\t"<<"\%eax,"<<result<<endl;
			break;
			case  UOR: 
					sout<<"\tmovl\t"<<arg1<<",\%edx"<<endl;
					sout<<"\tmovl\t"<<arg2<<",\%eax"<<endl;
					sout<<"\torl\t\%edx,\%eax"<<endl;
					sout<<"\tmovl\t"<<"\%eax,"<<result<<endl;
			break;  
			case AND: 
			break;
			case OR: 
			break;
			case LEQ_:
			   	sout<<"\tmovl\t"<<arg1<<",\%edx"<<endl;
				sout<<"\tmovl\t"<<arg2<<",\%eax"<<endl;
				sout<<"\tcmpl\t\%edx, \%eax"<<endl;
				sout<<"\tjge\t.L"<<atoi(result)<<endl;
			break;
			case GEQ_: 
				sout<<"\tmovl\t"<<arg1<<",\%edx"<<endl;
				sout<<"\tmovl\t"<<arg2<<",\%eax"<<endl;
				sout<<"\tcmpl\t\%edx, \%eax"<<endl;
				sout<<"\tjle\t.L"<<atoi(result)<<endl;
			break;
			case EQ_: 
				sout<<"\tmovl\t"<<arg1<<",\%edx"<<endl;
				sout<<"\tmovl\t"<<arg2<<",\%eax"<<endl;
				sout<<"\tcmpl\t\%edx, \%eax"<<endl;
				sout<<"\tje\t.L"<<atoi(result)<<endl;
			break;
			case NEQ_:
				sout<<"\tmovl\t"<<arg1<<",\%edx"<<endl;
				sout<<"\tmovl\t"<<arg2<<",\%eax"<<endl;
				sout<<"\tcmpl\t\%edx, \%eax"<<endl;
				sout<<"\tjne\t.L"<<atoi(result)<<endl;
			break;
			case LT_ :
				sout<<"\tmovl\t"<<arg1<<",\%edx"<<endl;
				sout<<"\tmovl\t"<<arg2<<",\%eax"<<endl;
				sout<<"\tcmpl\t\%edx, \%eax"<<endl;
				sout<<"\tjg\t.L"<<atoi(result)<<endl;
			break;
			case GT_: 
				sout<<"\tmovl\t"<<arg1<<",\%edx"<<endl;
				sout<<"\tmovl\t"<<arg2<<",\%eax"<<endl;
				sout<<"\tcmpl\t\%edx, \%eax"<<endl;
				sout<<"\tjl\t.L"<<atoi(result)<<endl;
			break;
			case CALL : 
				sout<<"\tcall\t"<<arg1<<endl;
				sout<<"\tmovl\t"<<"\%eax,"<<result<<endl;
				counter=1;				
			break;
			case ARR_DREF:   
					   sout<<"\tmovl\t"<<arg2<<",\%eax"<<endl;
					   sout<<"\tmovl\t"<<arg1<<"(,\%eax,1),"<<"\%eax"<<endl;
					   sout<<"\tmovl\t"<<"\%eax,"<<result<<endl;
			break;
			case ARR_REF:    
					  sout<<"\tmovl\t"<<arg2<<",\%eax"<<endl;
					  sout<<"\tmovl\t"<<arg1<<",\%edx"<<endl;
					  sout<<"\tmovl\t"<<"\%eax,"<<result<<"(,\%edx,1)"<<endl;
			break;
		}
	}
	else if(arg1!=0) //Unary Operator
	{
			  int arg1_off= lookup_ActRecFunt(arg1,AR);		
		          int rslt_off= lookup_ActRecFunt(result,AR);
	   
      
		       char *ebp="\%ebp";
		       if(arg1_off) { arg1=new char[30];  sprintf(arg1,"%d(%s)",arg1_off,ebp);}
		       if(rslt_off) { result=new char[30];  sprintf(result,"%d(%s)",rslt_off,ebp);}

			if(isNumeric(arg1)) {char *buffer= new char[20]; sprintf(buffer,"$%s",arg1); arg1=buffer;}	 	
			else if(arg1[0]=='\'')	{int c=arg1[1]; sprintf(arg1,"$%d",c);}
			
			char *is_string=lookup_String_Table(arg1);
         
		
		 switch(op)
		{
			
			case ASSIGN :
                if(is_string)  sout<<"\tmovl\t$"<<is_string<<",\%eax"<<endl;
                else 
				sout<<"\tmovl\t"<<arg1<<",\%eax"<<endl;
				sout<<"\tmovl\t"<<"\%eax, "<<result<<endl;      
			break;
			case  UMINUS:
				sout<<"\tmovl\t"<<arg1<<",\%eax"<<endl;
				sout<<"\tnegl\t%eax"<<endl;
				sout<<"\tmovl\t"<<"\%eax, "<<result<<endl;    
			break;
			case  UBNEG: 
				sout<<"\tmovl\t"<<arg1<<",\%eax"<<endl;
				sout<<"\tnotl\t%eax"<<endl;
				sout<<"\tmovl\t"<<"\%eax, "<<result<<endl;  
			break;
			case  UNOT:        
				sout<<"\tmovl\t"<<arg1<<",\%eax"<<endl;
				sout<<"\ttestl\t\%eax,\%eax"<<endl;
				sout<<"\tsete\t\%al"<<endl;
				sout<<"\tmovzbl\t\%al,\%eax"<<endl;
				sout<<"\tmovl\t"<<"\%eax, "<<result<<endl;  
			break;
			case  IF:       
				
			break;
			case  ADDR:       
				sout<<"\tmovl\t$"<<arg1<<","<<result<<endl;
			break;
			case  DREF:     
				sout<<"\tmovl\t"<<arg1<<", \%eax"<<endl;
				sout<<"\tmovl\t(\%eax),\%eax"<<endl;
				sout<<"\tmovl\t\%eax,"<<result<<endl;
			break;
			case  STR:      
				sout<<"\tmovl\t"<<result<<", \%eax"<<endl;
				sout<<"\tmovl\t"<<arg1<<", \%edx"<<endl;
				sout<<"\tmovl\t\%edx,(\%eax)"<<endl;
			break;
		}
	}
	else 
         if(result!=NULL)  // Not an Operator
	{ 
              
		       int rslt_off= lookup_ActRecFunt(result,AR);
		       char *ebp="\%ebp";int p1;
		       if(rslt_off) { result=new char[30];  sprintf(result,"%d(%s)",rslt_off,ebp);}

		switch(op)
		{ 
			case  GOTO:  sout<<"\tjmp .L"<<result<<endl;   
 			break;
			case  PARAM: 
				sout<<"\tmovl\t"<<result<<",\t\%ecx"<<endl;;
				p1=(counter==1)?0:4*counter-4;
                		sout<<"\tmovl\t\%ecx,"<<p1<<"(\%esp)"<<endl;
                			counter++;
			break;
			case  RETURN: 
			      sout<<"\tmovl\t"<<result<<",\%eax"<<endl;
			break;
		}
	}
    	
}

